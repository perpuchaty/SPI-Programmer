/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2022 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */
//this chamge is done in linux.
//this in windows
#include <stdint.h>
#include "stm32g431xx.h"
#include "config.h"
#include "spi_flash.h"
#include "spi_flash_target.h"

#include "uart.h"
#include "delay.h"
#include "system.h"
#include "ILI9341/config.h"
#include "ILI9341/graph.h"
#include "ILI9341/text.h"
#include "ILI9341/core.h"
#include "ILI9341/fonts/glcdfont.h"
#include "gui.h"
#include "flash.h"

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

int main(void)
    {

    config_cpu();
    LCD_init();
    LCD_fillScreen(BLACK);
    GPIOF->BSRR |= GPIO_BSRR_BS0; //LCD Backlight
    // LCD_DrawImage(0, 0, 320, 102, praxis_logo);
    gui_draw_status(STATUS_LOADING);
    system_chips_id();
    crc32 = system_get_checksum();
    if (crc32 != spi_flash_get_crc())
	{
	//Checksum stored in CPU is not the same as CRC calculated from source.
	errors.checksumCheck = 1;
	gui_draw_status(STATUS_TARGET_CRC_FAIL);
	while (progress_flag.start_triggered == 0);
	delayms(250);
	progress_flag.start_triggered = 0;
	}

    gui_draw_status(2);
    gui_draw_main_screen();
    //===============Loop===============//
    for (;;)
	{

	progress_flag.operation_in_progress = 0;
	system_chips_id();
	if (progress_flag.update_main_screen == 1)
	    {
	    gui_refresh_main_screen_source();
	    gui_refresh_main_screen_target();
	    progress_flag.update_main_screen = 0;
	    }
	delayms(100);

	if (progress_flag.start_triggered == 1) //Button is pressed
	    {
	    if (flashTarget.number_of_blocks >= flashSource.number_of_blocks)
		{
		system_process(); //Program chip
		}
	    else
		{
		gui_draw_status(STATUS_FLASH_SIZE_INCORECT);
		while (progress_flag.start_triggered == 0);
		delayms(250);
		progress_flag.start_triggered = 0;
		}
	    }
	}
    //===============Loop===============//
    }

void SysTick_Handler()
    {
    delay();

    if (progress_flag.erase_in_progress == 1)
	{
	progressvar.progress_timeout_cnt++;
	if (progressvar.progress_timeout_cnt == 1000)
	    {
	    progressvar.progress_timeout++;
	    progressvar.progress_timeout_cnt = 0;
	    }
	}

    if (progress_flag.operation_in_progress == 1)
	{
	total_time_div++;
	if (total_time_div == 1000)
	    {
	    total_time_div = 0;
	    total_time++;
	    }
	}
    }

void EXTI0_IRQHandler()
    {
    if ( EXTI->PR1 & EXTI_PR1_PIF0)
	{
	EXTI->PR1 |= EXTI_PR1_PIF0; //Button pressed
	if (GPIOA->IDR & GPIO_IDR_ID0)
	    GPIOA->BSRR |= GPIO_BSRR_BS1;
	else
	    GPIOA->BSRR |= GPIO_BSRR_BR1;
	progress_flag.start_triggered = 1;
	}
    }

void USART2_IRQHandler(void)
    {
    uint8_t rx = USART2->RDR;
    if (progress_flag.uart_mode == 1) //Flash programming is in progress
	{
	dbg.usb_bytes_recivied++;
	total_time = 0;
	if (uart1_rx_buffer_position < 4096)
	    {
	    flashSource.sector1[uart1_rx_buffer_position] = rx;
	    }
	else
	    {
	    checksum_usb = checksum_usb + (rx << (uart1_rx_buffer_position - 4096) * 8);
	    }
	uart1_rx_buffer_position++;

	if (progressvar.counter == flashSource.number_of_sectors && uart1_rx_buffer_position == 4) //Programming is finished, checksum is in buffer
	    {
	    gui_draw_status(STATUS_CHIP_VERIFY);
	    checksum_usb = flashSource.sector1[0] + (flashSource.sector1[1] << 8) + (flashSource.sector1[2] << 16) + (flashSource.sector1[3] << 24);
	    if (spi_flash_get_crc() == checksum_usb) //get source chip CRC
		{
		send_string("OK\r\n");
		system_set_checksum(checksum_usb, &filename);
		gui_draw_status(STATUS_CHIP_VERIFY_PASSED);
		while(GPIOA->IDR & GPIO_IDR_ID0);//Wait for button press
		GPIOF->BSRR |= GPIO_BSRR_BR0; //LCD Backlight
		NVIC_SystemReset();
		}
	    else
		{
		send_string("FAIL\r\n");
		gui_draw_status(STATUS_CHIP_VERIFY_FAILED);
		}
	    }

	if (uart1_rx_buffer_position == 4100) //entire buffer filled in, program it
	    {

	    //Calculate CRC
	    for (uint16_t j = 0; j < 4096 / 4; j++)
		{
		CRC->DR = __REV(*(uint32_t*) (uintptr_t) &flashSource.sector1[j * 4]);
		}
	    uint32_t crc32 = CRC->DR;
	    CRC->CR |= CRC_CR_RESET;
	    if (crc32 == checksum_usb) //checksum is fine, let's program sector
		{
		for (uint16_t i = 0; i < flashSource.sector_size / 256; i++) //Loop for each sector
		    {
		    while (spiFlags.read_busy); //Buffer is not ready yet
		    spi_write_cmd(0x06); 		//Write Enable
		    spi_flash_page_program((flashSource.sector_size * progressvar.counter) + (i * 256), 256, &flashSource.sector1[i * 256]); //Program from buffer 1
		    while (spi_read_status_register()); //Pool status register until it is 0
		    }
		progressvar.counter++;
		uart1_rx_buffer_position = 0;
		//! is transferred after each sector is flashed
		 dbg.usb_crc_pass++;
		send_string("!\n");
		}
	    else
		//Checksum mismatch, ask for frame once again
		{
		uart1_rx_buffer_position = 0;
		dbg.usb_crc_fail++;
		send_string("?\n");
		}
	    checksum_usb=0;
	    }
	}

    else if(progress_flag.wait_for_filename == 1)
	{
	/*Filename is sent right after chip erase is complete*/
	if(rx=='\n' || uart1_rx_buffer_position==15)
	    {
	    filename[uart1_rx_buffer_position]=0;
	    progress_flag.wait_for_filename=0;
	    uart1_rx_buffer_position=0;
	    }
	    else
	    {
	    filename[uart1_rx_buffer_position]=rx;
            uart1_rx_buffer_position++;
	    }
	}
    else
    //Connection modes
    //? - ping
    //!- programming mode on, after this programmer will wait for data frame
    //C- chip erase
    //R- source chip dump -TODO
    //D- device id- show USB picture on screen
	{
	if (rx == '?') //ping
	    {
	    send_string("!\r\n");
	    }

	if (rx == '!') //programming
	    {
	    //send_string("!\r\n");
	    gui_draw_status(STATUS_CHIP_PROGRAMMING);
	    progress_flag.uart_mode = 1;
	    progressvar.counter = 0;
	    }
	if (rx == 'C') //chip erase command
	    {
	    send_string("CHIP_ERASE\r\n");
	    gui_draw_status(STATUS_CHIP_ERASE);	//Draw status on screen
	    progress_flag.erase_in_progress = 1;	//Set flag
	   progress_flag.operation_in_progress = 1;	//Set flag
	    spi_flash_source_chip_erase();//Send chip erase command (0x06,0x60 - this is good for winbond flash)

	    while (progress_flag.erase_in_progress)
		{
		if (spi_read_status_register() == 0) //chip is erased because status register is 0
		    {
		    progress_flag.erase_in_progress = 0;
		    }
		else
		    {
		    progress_flag.erase_in_progress = 1; //Chip erase is in progress
		    }

		}
	    send_string("DONE\r\n");
	    progress_flag.wait_for_filename = 1;

	    }
	if (rx == 'R') //Source chip read
	    {

	    }
	if (rx == 'D') //Device ID
	    {
	    uint8_t devid = flashSource.id >> 8;
	    uint8_t devsize = (uint8_t) flashSource.id;

	    send_char(devid);
	    send_char(devsize);
	    LCD_fillScreen(BLACK);
	    LCD_DrawImage(96, 10, 128, 128, usb);
	    }
	else
	    {
	    total_time = 0;
	    }
	}
    }

void DMA1_CH2_IRQHandler()
    {
    //SOURCE RX
    spi_flash_irq_handler();
    }

void DMA1_CH4_IRQHandler()
    {
    //TARGET RX
    spi_flash_target_irq_handler();
    }

