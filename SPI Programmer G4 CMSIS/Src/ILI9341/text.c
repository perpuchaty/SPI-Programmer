#include "text.h"

uint8_t _cp437 = 0;

uint8_t space = 0;


uint16_t cursorX = 0,
    cursorY = 0;

uint8_t textSize = 1;

uint8_t wrap = 1;


    textBgColor = TRANSPARENT_COLOR;


uint8_t LCD_drawChar(uint16_t x0, uint16_t y0, unsigned char c, uint16_t color, uint16_t bg, uint8_t * font) {
    //alpha version of function that accept font generated by GLCD FONT CREATOR 2.Returns character width.

	uint8_t firstChar=font[4];
	uint8_t charWidth = font[(6 + c - firstChar)];
	uint8_t height = font[3];
	uint8_t charHeightDataCount = (height / 8);
	if (height % 8 > 0) charHeightDataCount++; // This two lines determine how many bytes per line is in *font

	uint8_t charCount = font[5];

	uint16_t x1 = (uint16_t) (x0 + charWidth - 1), y1 = (uint16_t) (y0 + height
			- 1);

	//  uint16_t doubleSize = size * size;
	uint32_t count = charWidth * height;

	uint16_t charPixels[count];

	uint16_t i, j, k;

	uint8_t currentByte;

	if (x0 >= LCD_getWidth() || y0 >= LCD_getHeight() || x1 < 0 || y1 < 0) return 0;

	// if (!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior
	//Now we calculate correct adress for first byte of char
	uint16_t p = 0;
	for (uint16_t g = 6; g < 6 + c - firstChar; g++) //
	{
		p = p + font[g];
	}
	uint16_t characterPosition = 6 + charCount + (p * charHeightDataCount);

	if (bg == TRANSPARENT_COLOR)
	{
		LCD_readPixels(x0, y0, x1, y1, charPixels);
	}

	LCD_setAddressWindowToWrite(x0, y0, x1, y1);



	//charWidth=4;
	for (i = 0; i < count; i++)
	{
		charPixels[i] = 0;
	}

	for (j = 0; j < charHeightDataCount; j++)
	{
		for (i = 0; i < charWidth; i++)
		{
			//currentByte = (uint8_t) ( i < charWidth + 1 ? font[characterPosition] : 0x0);
			currentByte = (uint8_t)font[characterPosition] ;
			if (j == charHeightDataCount-1)
			{
				currentByte >>= 8-(height % 8);
			}
			for (k = 0; k < 8; k++, currentByte >>= 1)
			{
if (j==charHeightDataCount-1 && k== height % 8)break; // todo check this line, without this there is hard fault, probably characterPosition is out of range
//				if (k == 7 && j == 1) break;
				uint32_t a = ((k * (charWidth)) + i) + (j * 8 * charWidth);
//				if (j == 1)
//				{
//					int i = 0;
//					i++;
//				}
				charPixels[a] = currentByte & 0x1 ? color : bg;
			}
			characterPosition++;
		}
	}
    LCD_setSpi16();
    dmaSendData16(charPixels, count);
    LCD_setSpi8();
    return charWidth;
}

uint8_t calc_string_pixels(unsigned char c, uint8_t * font)
{
return font[(6 + c - font[4])];
}

inline void LCD_write(unsigned char c, uint8_t *font)
{
	uint8_t test;
	if (c == 32)	//fill space(ASCII=32) with background collor
	{
		test = font[2];
		LCD_fillRect(cursorX - space, cursorY, test, font[3], textBgColor);
		cursorX = cursorX + test;

	}
	else
	{
		test = LCD_drawChar(cursorX, cursorY, c, textColor, textBgColor, font);

		LCD_drawRect(cursorX - space, cursorY, space, font[3], textBgColor); //SPACE BETWEEN CHARS
		cursorX = cursorX + test + space;
	}
}

void LCD_writeString(char *s, uint8_t * font) {
    while (*(s)) LCD_write(*s++, font);
}

void LCD_writeStringCenter(unsigned char *s, uint8_t * font,uint8_t x,uint16_t lenght)
		{
	uint8_t charCount=0;
	uint16_t pixelCount=0;
	 while (*(s))
		 {
		 pixelCount=pixelCount+calc_string_pixels(*s++, font);
		 charCount++;
		 }
	 charCount=charCount+0;
	 LCD_setCursor(x+(lenght/2)-(pixelCount/2),LCD_getCursorY());
s=s-charCount;
while (*(s)) LCD_write(*s++, HelveticaNeue25);


		}

void LCD_setCursor(uint16_t x, uint16_t y) {
    cursorX = x;
    cursorY = y;
}

void LCD_setTextSize(uint8_t size) {
    textSize = size;
}

void LCD_setTextColor(uint16_t color) {
    textColor = color;
}

void LCD_setTextBgColor(uint16_t color) {
    textBgColor = color;
}

void LCD_setSpace(uint8_t s) {
    space = s;
}

uint16_t LCD_getCursorX() {
    return cursorX;
}

uint16_t LCD_getCursorY() {
    return cursorY;
}


void LCD_drawChar_tst(uint16_t x0, uint16_t y0, unsigned char c, uint16_t color, uint16_t bg, uint8_t size) {
    uint16_t scaledWidth       = (uint16_t) (size * 6),
        doubleScaledWidth = scaledWidth * size;

    uint16_t x1 = (uint16_t) (x0 + scaledWidth - 1),
        y1 = (uint16_t) (y0 + 8 * size - 1);

    uint16_t doubleSize = size * size;
    uint16_t count      = (uint16_t) (48 * doubleSize);

    uint16_t charPixels[count];

    uint16_t mx, my;
    uint32_t  i, j, sx, sy;
    //todo
    uint8_t  line;
    uint16_t pixelColor;

    if (x0 >= LCD_getWidth() || y0 >= LCD_getHeight() || x1 < 0 || y1 < 0) return;

    if (!_cp437 && (c >= 176)) c++; // Handle 'classic' charset behavior

    uint16_t characterNumber = (uint16_t) (c * 5);

    if (bg == TRANSPARENT_COLOR) {
        LCD_readPixels(x0, y0, x1, y1, charPixels);
    }

    LCD_setAddressWindowToWrite(x0, y0, x1, y1);

    for (i = 0; i < 6; i++) {
       // line = (uint8_t) (i < 5 ? pgm_read_byte(font + characterNumber + i) : 0x0);
        my   = (uint16_t) (i * size);


        for (j = 0; j < 8; j++, line >>= 1) {
            mx = (uint16_t) (j * doubleScaledWidth);

            pixelColor = line & 0x1 ? color : bg;

            if (pixelColor == TRANSPARENT_COLOR) continue;

            for (sx = 0; sx < size; ++sx) {
                for (sy = 0; sy < size; ++sy) {
                    charPixels[mx + my + sy * scaledWidth + sx] = pixelColor;
                }
            }
        }
    }

    LCD_setSpi16();
    dmaSendData16(charPixels, count);
    LCD_setSpi8();
}





